from functools import reduce
from itertools import product

from qiskit import QuantumCircuit, QiskitError

import numpy as np
from qiskit.circuit import ParameterExpression
from qiskit.quantum_info import Clifford, StabilizerState, Pauli, Operator, Statevector


class CliffordPhi(QuantumCircuit):

    def __init__(self, n):
        super().__init__(n)

    def lattice_average(self, loss):
        """Compute loss average by summing over all lattice points."""

        def loss_func(params):
            state = Statevector.evolve(self)

            averages = [c*state.expectation_value(p) for c, p in loss.pauli_losses()]
            return sum(averages)

        grid = list(product(*[[0, 1]] * len(self.parameters)))
        grid = np.pi * np.array(grid)
        losses = [loss_func(p) for p in grid]

        return sum(losses) / len(losses)

    def average(self, loss):
        """Compute the average of the loss function over all parameters in the circuit."""
        # General loos will be represented as a sum of pauli losses.
        return sum([self.average_pauli(pauli_loss) for pauli_loss in loss.pauli_losses()])

    def average_pauli(self, pauli_loss):
        """Compute the average of a Pauli Hamiltonian over all parameters in the circuit."""
        coeff, pauli = pauli_loss
        loss_generators = self.generators_loss(self.support(pauli))
        multiplicity, group = self.pauli_group(loss_generators)
        return coeff * multiplicity * self.group_average(group, pauli)

    @staticmethod
    def support(pauli):
        return [i for i, gate in enumerate(pauli.to_label()) if gate != 'I']

    def group_average(self, group, pauli_string):
        """Compute the average (unnormalized) of a Pauli Hamiltonian over a group of Clifford operators."""
        group_sum = []
        for element in group:
            circuit = self.clifford_total().compose(element)
            state = StabilizerState(circuit)
            group_sum.append(state.expectation_value(pauli_string))

        return sum(group_sum)

    def clifford_total(self):
        """Clifford skeleton of the circuit, C(phi=0)."""
        return reduce(lambda c1, c2: c1.compose(c2), self.clifford_gates())

    def clifford_gates(self):
        """Clifford gates in the circuit."""
        parametric_gates, clifford_gates = self.gates()
        return clifford_gates

    def parametric_gates(self):
        """Parametric gates in the circuit."""
        parametric_gates, clifford_gates = self.gates()
        return parametric_gates

    @staticmethod
    def pauli_group(generators):
        """Compute the abelian group generated by a list of pauli operators."""
        group = [Pauli('I'*generators[0].num_qubits)]
        num_dependent_generators = 0
        for generator in generators:
            for g in group:
                if g.equiv(generator):
                    num_dependent_generators += 1
                    continue

                else:
                    group_times_generator = [g.compose(generator) for g in group]
                    group.append(group_times_generator)
        multiplicity = 2**num_dependent_generators

        return multiplicity, group

    def generators_loss(self, loss_support):
        """Generators of a Pauli group relevant for the qubits at loss support."""
        multiplicity_H, generators_H = self.generators_H()
        multiplicity_loss, generators_loss = self.factor(generators_H, loss_support)

        return multiplicity_H * multiplicity_loss, generators_loss

    def generators_H(self):
        """Generators of a Pauli group relevant for a generic loss function"""
        multiplicity_0, generators_0 = self.generators_0()
        generators_H = [gen.evolve(self.clifford_total()) for gen in generators_0]
        return multiplicity_0, generators_H

    def generators_0(self):
        """Generators of a Pauli group acting non-trivially after commuted to the vacuum state"""
        all_generators = []
        clifford_gates = self.clifford_gates()
        for gate in self.parametric_gates():
            gate_pauli = gate.pauli_operator()
            preceeding_clifford = reduce(lambda c1, c2: c1.compose(c2), clifford_gates[:gate.index])
            generator = gate_pauli.evolve(preceeding_clifford.adjoint())
            all_generators.append(generator)

        projected_generators = [Pauli.from_label(g.to_label().replace('Z', 'I')) for g in all_generators]
        multiplicity, generators = self.pauli_group(projected_generators)
        return multiplicity, generators

    @staticmethod
    def factor(generators, loss_support):
        """Identify generators acting in the same way on the loss support"""
        distinct_generators = []
        for generator in generators:
            factored_label = [gate if i in loss_support else 'I' for i, gate in enumerate(generator.to_label())]
            factored_generator = Pauli.from_label(''.join(factored_label))
            for g in distinct_generators:
                if g.equiv(factored_generator):
                    break
                distinct_generators.append(factored_generator)

        multiplicity = 2**(len(generators) - len(distinct_generators))

        return multiplicity, distinct_generators

    @staticmethod
    def _is_parametric(gate):
        return gate.params and isinstance(gate.params[0], ParameterExpression)

    def gates(self):
        clifford_gates = []
        parametric_gates = []

        clifford_gate = Clifford(QuantumCircuit(self.num_qubits))
        for gate, qargs, cargs in self.data:
            try:
                # If the gate is clifford extend the current one.
                gate = Clifford(gate)
                clifford_gate.compose(gate)
            except QiskitError:
                # If the gate is not clifford, add the current accumulated clifford one to the list and start a new one.
                clifford_gates.append(clifford_gate)
                clifford_gate = Clifford(QuantumCircuit(self.num_qubits))

                # If the gate is parametric add it to the parametric list.
                if self._is_parametric(gate):
                    pauli_rotation = PauliRotation(gate, qargs, len(clifford_gates))
                    parametric_gates.append(pauli_rotation)

                else:
                    raise TypeError(f"Gate {gate} is neither Clifford nor parametric Pauli")

        return parametric_gates, clifford_gates


class PauliRotation:

    pauli_rotation_gates = {
        'rx': 'X',
        'ry': 'Y',
        'rz': 'Z',
    }

    def __init__(self, gate, qargs, index):
        self.gate = gate.name
        self.num_qubits = gate.num_qubits
        self.qubit_indices = [q._index for q in qargs]
        self.index = index

    def pauli_operator(self):
        label = 'I'*self.num_qubits
        for n, index in enumerate(self.qubit_indices):
            label[index] = PauliRotation.pauli_rotation_gates[self.gate][n]
        return Pauli.from_label(label)


X = np.array([[0, 1], [1, 0]], dtype=np.complex64)
Z = np.array([[1, 0], [0, -1]], dtype=np.complex64)


def multi_kronecker(matrix_list):
    return reduce(lambda m1, m2: np.kron(m1, m2), matrix_list)


class PauliString:
    def __init__(self, z, x):
        assert len(z) == len(x), f'Z and X stabilizers must have the same length, got Z:{len(z)} X:{len(x)}'
        self.z = z
        self.x = x
        self.num_qubits = len(z)

    def unitary(self):
        z_list = [Z if z == 1 else np.identity(2) for z in self.z]
        x_list = [X if x == 1 else np.identity(2) for x in self.x]
        return multi_kronecker(x_list) @ multi_kronecker(z_list)

    @staticmethod
    def product(s1, s2):
        z12 = (s1.z + s2.z) % 2
        x12 = (s1.x + s2.x) % 2
        return PauliString(z12, x12)

    @staticmethod
    def trivial(num_qubits):
        z = np.zeros(num_qubits, dtype=int)
        x = np.zeros(num_qubits, dtype=int)
        return PauliString(z, x)

    def __repr__(self):
        z_str = ''.join([str(z) for z in self.z])
        x_str = ''.join([str(x) for x in self.x])
        return f'PauliString({z_str}|{x_str})'

    def __eq__(self, other):
        if isinstance(other, PauliString):
            return np.array_equal(self.z, other.z) and np.array_equal(self.x, other.x)
        return False

    def __hash__(self):
        return int(''.join([str(i) for i in np.concatenate([self.z, self.x])]), 2)

