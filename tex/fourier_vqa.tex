\documentclass[twocolumn, amsfonts, amssymb, aps, nofootinbib]{revtex4-2}
\raggedbottom
\usepackage[T1]{fontenc}
\usepackage{tgtermes}
\usepackage{amsmath}
\usepackage{empheq}
\usepackage{enumitem}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage[braket, qm]{qcircuit}
\usepackage{braket}
\usepackage{hyperref}
\usepackage{placeins}
\usepackage{xcolor}
\usepackage{soul}
\usepackage{tikz}
\usepackage{bbm}
\usepackage{subcaption}
\hypersetup{
	colorlinks   = true, %Colours links instead of ugly boxes
	urlcolor     = blue, %Colour for external hyperlinks
	linkcolor    = blue, %Colour of internal links
	citecolor   = red %Colour of citations
}

\newcommand{\CZ}{\textsf{CZ }}
\newcommand{\CX}{\textsf{CNOT}}
\newcommand{\T}{\textsf{T }}
\newcommand{\tgate}[1]{\textcolor{blue}{#1}}
\newcommand{\cx}[1]{C${}^{#1}$X}
\newcommand{\cz}[1]{C${}^{#1}$Z}
\newcommand{\package}[1]{\textrm {#1 }}
\newcommand{\cpflow}{\package{CPFlow}}
\newcommand{\static}{\textsc{static }}
\newcommand{\adaptive}{\textsc{adaptive }}
\newcommand{\param}[1]{\texttt{#1}}
\newcommand{\teal}[1]{{\color{Teal} #1}}

\newcommand{\comment}[1]{\textcolor{red}{#1}}

\newcommand{\CP}{Clifford+Pauli}
\begin{document}

\title{Efficient variational synthesis of quantum circuits with coherent multi-start optimization}

\author{Nikita A. Nemkov}\email{nnemkov@gmail.com}
\affiliation{Russian Quantum Center, Skolkovo, Moscow 143026, Russia}
\affiliation{National University of Science and Technology ``MISIS”, Moscow 119049, Russia}
\author{Evgeniy O. Kiktenko}
\affiliation{Russian Quantum Center, Skolkovo, Moscow 143026, Russia}
\affiliation{National University of Science and Technology ``MISIS”, Moscow 119049, Russia}
\author{Ilia A. Luchnikov}
\affiliation{Russian Quantum Center, Skolkovo, Moscow 143026, Russia}
\affiliation{National University of Science and Technology ``MISIS”, Moscow 119049, Russia}
\author{Aleksey K. Fedorov}\email{akf@rqc.ru}
\affiliation{Russian Quantum Center, Skolkovo, Moscow 143026, Russia}
\affiliation{National University of Science and Technology ``MISIS”, Moscow 119049, Russia}

\begin{abstract}
We consider the problem of the variational quantum circuit synthesis into a gate set consisting of the \CX gate and arbitrary single-qubit (1q) gates, with the primary objective being the minimization of the \CX count. First, we note that along with the discrete architecture search, suffering from the combinatorial explosion of complexity, optimization over 1q gates can also be a crucial roadblock due to the omnipresence of local minimums (well known in the context of variational quantum algorithms but apparently underappreciated in the context of the variational compiling). Taking the issue seriously, we make an extensive search over the initial conditions an essential part of our approach.
Another key idea we propose is to use parametrized two-qubit (2q) controlled phase gates, which can interpolate between the identity gate and the \CX gate, and allow a continuous relaxation of the discrete architecture search, which can be executed jointly with the optimization over 1q gates. This coherent optimization of the architecture together with 1q gates appears to work surprisingly well in practice, sometimes even outperforming optimization over 1q gates alone (for fixed optimal architectures).
As illustrative examples and applications we derive 8 \CX and \T depth 3 decomposition of the 3q Toffoli gate on the nearest-neighbor topology, rediscover known best decompositions of the 4q Toffoli gate on all 4q topologies including a  1 \CX gate improvement on the star-shaped topology, and propose decomposition of the 5q Toffoli gate on the nearest-neighbor topology with 48 \CX gates. We also benchmark the performance of our approach on a number of 5q quantum circuits from the ibm\_qx\_mapping database showing that it is highly competitive with the existing software. The algorithm developed in this work is available as a Python package \cpflow.
\end{abstract}

\maketitle

\tableofcontents

\section{Introduction and results}
\textbf{Don't forget}
\begin{itemize}
	\item Correlated angles
	\item Non-local information
	\item Mention that simulation=computing expectation values
\end{itemize}
\textbf{Keys}
\begin{itemize}
	\item Using Clifford properties for training of VQA
	\item Looking at Fourier expansions Shuld(+clone) +2 new ones
	\item De-quantizing re-uploading models
	\item Pauli solver + Izmaylov
\end{itemize}
\cite{Ryabinkin2020}
\section{Parameterized quantum circuits} \label{sec VQA}
In this section establish some notation, describe basic properties of variational circuits and loss functions, and discuss how Fourier expansion arises in this context.
\subsection{Trigonometric expansion of the unitary}
We will assume that a unitary matrix $U(\pmb{\phi})$ of a parameterized quantum circuit takes the following form 
\begin{align}
	U(\pmb{\phi})=C_M P_M(\phi_M)\dots C_2P_2(\phi_2)C_1 P_1(\phi_1) C_0 \ . \label{U phi}
\end{align}
Here $C_m$ are constant gates, while $P_m(\phi_m)=e^{i\frac{\phi_m}{2} G_m}$ are single-parameter rotations. We will assume that generators of the parameterized gates square to identity $G_m^2=1$, so that
\begin{align}
	P_m(\phi)=\mathbbm{1}\cos\frac{\phi}{2}+iG_m\sin\frac{\phi}{2} \ .
\end{align}
Applying this relation to every parametric gate in the circuit one obtains the following formal trigonometric expansion containing $2^M$ terms
\begin{align}
	U(\pmb{\phi})=\sum_I U_I t_I\left(\frac{\pmb{\phi}}2\right) \ . \label{U expansion}
\end{align}
Here $I\in\{0,1\}^M$ is a multi-index, $t_I(\pmb{\phi})$ is a multivariate trigonometric monomial of order $M$
\begin{align}
	t_I(\pmb{\phi})=\prod_{m=1}^M t_{I_m}(\phi_m) \label{t def} \ ,
\end{align}
where each term in the product is defined by
\begin{align}
	t_i(\phi)=\cos^{1-i}\phi\sin^i\phi=\begin{cases}\cos\phi,\quad i=0\\\sin\phi,\quad i=1\end{cases} \ .
\end{align}
We note that coefficient matrices $U_I$ correspond to the circuit unitary evaluated at specific values $U_I=U(\pmb{\phi}=\pi I)$.
\subsection{Fourier expansion of the loss function}
Most commonly, the loss function $F(\pmb\phi)$ of a variational algorithm is defined by the average of some hermitian operator $H$, often referred to as the Hamiltonian, in the state prepared by the circuit 
\begin{align}
	F(\pmb{\phi})=\Braket{0|U^\dagger(\pmb\phi)HU(\pmb\phi)|0} \ . \label{F def}
\end{align}
Substituting expansion \eqref{U expansion} into the loss function gives
\begin{align}
	F(\pmb{\phi})=\sum_{IJ}t_I\left(\frac{\pmb \phi}{2}\right)t_J\left(\frac{\pmb \phi}{2}\right)\Braket{0|U^\dagger_IHU_J|0} \ . \label{F exp}
\end{align}
In contrast to the expansion of the unitary \eqref{U expansion}, expansion of the loss function when expressed as a polynomial in $\cos\phi_m,\sin\phi_m$, i.e. as the standard Fourier series, is not homogeneous, see App.~\ref{app explicit} for details. Let us organize the Fourier expansion of the loss function by level
\begin{align}
	F(\pmb\phi)=\sum_{m=0}^M F_m(\pmb\phi) \ . \label{Fm def}
\end{align}
Each level $F_m(\pmb\phi)$ only involves monomials of order $m$.
There are $\binom{M}{m}$ possible subsets of parameters at level $m$ each giving rise to $2^m$ trigonometric monomials. Hence, the total number of independent coefficients in the Fourier expansion is
\begin{align}
	\sum_{m=0}^M 2^{m}\binom{M}{m}=3^M \label{3M coeffs} \ .
\end{align}
\subsection{Fourier terms from averages}
Computing the Fourier series for generic loss functions appears to be a formidable task. Indeed, let us note that the constant term $F_0$ in the Fourier expansion can be thought of as the loss function averaged over all parameters
\begin{align}
	F_0=\Braket{F(\pmb\phi)}_{\pmb\phi}:=\frac{1}{(2\pi)^M}\int_0^{2\pi}\prod_{m=1}^Md\phi_m\,\, F(\pmb\phi) \ . \label{F avg}
\end{align}
This relation holds because all higher levels $F_{m>0}(\pmb\phi)$ in the Fourier series trivially vanish when averaged. Higher level terms can be expressed similarly, see App.~\ref{app explicit}.

The average in \eqref{F avg} can be expressed in a succinct form using orthogonality of trigonometric monomials $t_I$ \eqref{t def}  
\begin{align}
	\Braket{t_I(\pmb\phi) t_J(\pmb\phi)}_{\pmb\phi}=2^{-M}\delta_{IJ} \ . \label{t product}
\end{align}
Hence, averaging \eqref{F exp} yields
\begin{align}
	F_0=\frac{1}{2^M}\sum_{I}\Braket{0|U_I^\dagger H U_I|0} \ . \label{F0}
\end{align}

Finding even the lowest order term $F_0$ in the Fourier series seems to be out of reach for generic circuits. In terms of a classical simulation, computing any single average in \eqref{F0} is difficult on its own for a sufficiently large number of qubits. Even when the averages can be computed efficiently, via simulation or provided an access to a quantum computer, equation \eqref{F0} still requires summing $2^M$ terms, infeasible for any significant number of parameters $M$.

As we show in the next section, for a special class of quantum circuits that we refer to as \CP{}, evaluating $F_0$ and in fact any particular monomial in the Fourier expansion is classically efficient. 
\section{\CP{} variational circuits}
\subsection{Definition and properties}
Let us first establish some notation relevant for stabilizer circuits. A single-qubit Pauli operator is simply an $X, Y, Z$ Pauli matrix or an identity, possibly with a phase $\pm1, \pm i$. An $n$-qubit Pauli operator is a tensor product of $n$ arbitrary single-qubit Pauli operators. Any two Pauli operators either commute or anti-commute $P_1P_2=\pm P_2P_1$. Clifford gates $C$ are operators that transform Pauli gates into Pauli gates $C^\dagger P C=P'$. The group of Clifford gates can be generated by the Hadamard gate $H$, $S=\sqrt{Z}$ and $\CX{}$. Circuits consisting only of the Clifford gates applied to the stabilizer states (of which $|0\rangle$ is an example) can be efficiently simulated classically due to the Gottesman-Knill theorem \cite{Aaronson2004}.

We define \CP{} variational circuits as a subset of variational circuits \eqref{U phi}, where generators of parametric gates are Pauli operators and all constant gates are Clifford gates. For clarity of exposition, we will also assume that the Hamiltonian $H$ is also a Pauli operator. The case that is most relevant in practice, when the Hamiltonian is a polynomial-size sum of Pauli operators, can be handled by linearity. We stress that both the Pauli generators and the Hamiltonian are allowed to have arbitrary weight, i.e. be supported on any number of qubits.
Note that Pauli rotations with generic angles are not Clifford gates, and hence \CP{} circuits can not be simulated efficiently using the stabilizer formalism. 

\CP{} circuits admit a simple canonical form, where all Clifford gates are illuminated. First, one uses commutation properties of Clifford and Pauli operators to drag all the Clifford gates to the very end of the circuit. Generators of Pauli rotations will generally change during the process. The Clifford gate accumulated at the end of the circuit can be absorbed into the Hamiltonian $H$, which also remains a Pauli operator. Hence, without loss of generality we will assume that \CP{} variational circuit takes the following form
\begin{align}
	U(\pmb\phi)=P_M(\phi_M)P_{M-1}(\phi_{M-1})\dots P_1(\phi_1) \ .
\end{align}
It will be convenient to denote a generic \CP{} circuit in the canonical form by $(P_1\dots P_M|H)$.

\subsection{Computing averages}
Now let us revisit the computation of the average loss function \eqref{F0}. Let $\mathcal{P}$ be the subgroup of the Pauli group, generated by Pauli generators of the circuit. Then
\begin{align}
	F_0=\frac{1}{2^M}\sum_{P\in \mathcal{P}}\Braket{0|PHP|0} \ . \label{F0P}
\end{align}
We claim that this sum vanishes unless $[H, \mathcal{P}]=0$. Indeed, assume there is $P_m$ such that $P_mH=-HP_m$. Then for every term $P$ in sum \eqref{F0P} there is a term with $P'=PP_m$ giving the opposite contribution. Hence for \CP{} circuit with a Pauli Hamiltonian $H$
\begin{align}
	F_0=\begin{cases} \braket{0|H|0},\quad [H, \mathcal{P}] = 0\\ 0,\qquad\qquad \text{else}\end{cases} \ .
\end{align}
Therefore, computing the average loss function for \CP{} circuits is a trivial task for any number of qubits and any number of parameters. In fact, as we show in the following, this applies to every individual term in the full Fourier expansion. The difficulty of computing the full Fourier expansion then solely stems from the fact that the total number of non-vanishing coefficients ca be exponentially large. In the next section we present an efficient classical algorithm to compute Fourier expansion level by level.
\section{Classical algorithm}
\subsection{Expansion of the dressed Hamiltonian}
\begin{figure}
	\includegraphics[width=0.5\textwidth]{figures/tree.png}
	\caption{A sample diagram representing recursive expansion of a dressed Hamiltonian}
	\label{fig tree}
\end{figure}


Let us introduce operator
\begin{align}
	H(\pmb\phi)=U^\dagger(\pmb\phi)HU(\pmb\phi)\ ,
\end{align}
which, following the quantum chemistry literature, we will call the dressed Hamiltonian. The loss function is the average of the dressed Hamiltonian in the all-zero state
\begin{align}
	 F(\pmb\phi)=\Braket{0|H(\pmb\phi)|0} \ . \label{F from H dressed}
\end{align}
Next we make the following simple observation
\begin{align}
	P(\phi)^\dagger HP(\phi)=\begin{cases} H,\quad [P, H]=0\\ P\cos\phi+iPH\sin\phi,\quad \{P,H\}=0\end{cases} \ ,
\end{align}
i.e. when the conjugating Pauli rotation commutes with $H$ it cancels out, while for an anti-commuting Pauli rotation the result can be written as a sum of two Pauli operators. This gives a recurrence procedure to expand the dressed Hamiltonian
\begin{align}
H(\pmb\phi_M)=\begin{cases} H(\pmb\phi_{M-1}),\quad [P_M, H]=0\\ H(\pmb\phi_{M-1})\cos\phi_M+(iP_MH)(\pmb\phi_{M-1})\sin\phi_M \ .\end{cases} \label{H cases}
\end{align}
The expansion procedure can be conveniently visualized as a binary tree, see Fig.~\ref{fig tree} for an example, which is constructed as follows. The nodes, which we will refer to as the computational nodes, correspond to variational circuits, specified by the a set of Pauli generators and an observable $O$, jointly denoted as $(P_1\dots P_m|O)$. At any given node, if the observable $O$ anti-commutes with the last Pauli generator $P_m$, the node branches into two $(P_1\dots P_m|O)\to\cos\phi_m (P_1\dots P_{m-1}|O)+i\sin\phi_m (P_1\dots P_{m-1}|P_m O)$. For brevity, we omit coefficients at the diagram. Branching increases the Fourier level by one. If the last Pauli generator instead commutes with $O$, it is simply removed $(P_1\dots P_m|O)\to (P_1\dots P_{m-1}|O)$ and the Fourier level remains unchanged. We depict this by horizontal arrows at the diagram. When there are no Pauli generators left, the node contains the final observable encoding a single operator coefficient in the Fourier expansion of the dressed Hamiltonian.


The graphical representation makes several distinctive features of Fourier series for \CP{} circuits manifest. Let $n(m)$ be the number of Fourier modes at level $m$. Introduce
\begin{align}
	\delta(m)=\sum_{k=0}^m2^{-k}n(k) \label{delta def} \ .
\end{align}
For any \CP{} circuit and any Pauli Hamiltonian it holds
\begin{align}
\delta(M)=\sum_{m=0}^M 2^{-m}n(m)=1 \ , \label{invariant}
\end{align}
i.e. the weighted sum of populations of Fourier levels is an invariant. 

This implies certain constraints on the distribution of Fourier terms. For example, the maximum number of Fourier terms $\sum_m n(m)$ is upper bounded by $2^M$ (when the last level is fully populated), cf. the bound for generic circuits $3^M$ \eqref{3M coeffs}. Importantly, the presence of any single Fourier term at level $m<M$ reduces the maximum possible amount of terms at other levels. For instance, if $n(0)=1$, i.e. $F_0\neq0$, all other Fourier terms vanish. 
\subsection{Accounting for the expectation values} \label{sec pruning}
So far we discussed the expansion of the dressed Hamiltonian. In turn, the loss function  is given by its expectation value in the all-zero state \eqref{F from H dressed}. A likely scenario is that the majority of the final Pauli observables have vanishing expectations, and hence do not contribute to the loss function. This observation allows to significantly enhance the efficiency of the computation by pruning unfit branches in advance.

Let us denote factorization of a general Pauli operator $P$ into $Z$ and $X$ operators as $P=P(Z)P(X)$. A Pauli observable $O$ has a non-zero vacuum expectation value if $O(X)=0$. 
First assume for simplicity that the first $N$ Pauli generators $P_1\dots P_N$ form the basis in the space of $X$ strings, i.e. there is a unique way to decompose $O(X)$ as a product $O(X)=\prod_{i=1}^N P^{k_i}_i(X)$ where $k_i=0,1$. Now consider the computational node $(P_1\dots P_N|O)$. If we apply the expansion algorithm directly, up to $2^N$ terms will be generated, but only a single one can yield a non-zero vacuum expectation. Instead, we can first decompose $O(X)$ into the product of $P_i(X)$ and then check if this product is compatible with the branching rules. This yields an exponential saving for large $N$.


Now let us lift the restriction of the first $N$ Pauli generators forming a basis. The necessary condition for $(P_1\dots P_m|O)$ to have a non-zero vacuum expectation is for $O(X)$ to be contained in the span of $P_i(X)$. Each time that another independent generator $P_m(X)$ is removed during the expansion of the dressed Hamiltonian, we can check if $O(X)$ is still contained in the span of the remaining Pauli generators. If it is not, all final observables stemming from the expansion of this node will give zero expectation values, and the node can be disregarded.
\subsection{Truncated Fourier series as an approximation} \label{sec truncation}
Having many terms on low Fourier levels appears to be convenient, because this partially reduces the proliferation of coefficients at subsequent levels. This is further reinforced by the observation that each individual term at a lower level contributes exponentially more to the loss function than a term at a higher level. Intuitively, this is because the average absolute value of a trigonometric monomial of order $m$ is $\left(\frac{2}{\pi}\right)^{m}$ and decays exponentially with the level. At the same time, there can be exponentially more terms at higher levels. We can quantify this trade-off by evaluating the $L^2$ norm of the loss function. From orthogonality of trigonometric monomials \eqref{t product} it follows
\begin{align}
	||F(\pmb\phi)||^2=\Braket{|F(\pmb\phi)|^2}_{\pmb\phi}=\sum_{m=0}^M 2^{-m}l(m) \ ,
\end{align}
where $l(m)$ is the number of non-zero Fourier terms in the expansion of the loss function at level $m$, which is upper bounded by the number of non-zero terms in the expansion of the dressed Hamiltonian $l(m)\le n(m)$. ( Note that $n(m)-l(m)$ is the number of observables at level $m$ with zero expectation value). Using \eqref{invariant} we can then bound the $L^2$ norm of the loss function
\begin{align}
	||F(\pmb\phi)||^2\le 1 \ .
\end{align}
Let $F^{(m)}(\pmb\phi)$ denote the Fourier series truncated to the first $m$ levels. Then
\begin{align}
	||F^{(m)}(\pmb\phi)-F(\pmb\phi)||^2\le \sum_{k=m+1}^M 2^{-k}l(k)\le 1-\delta(m) \ . \label{F bound}
\end{align}
If $\delta(m)$ is close to 1, i.e. sufficiently many terms are concentrated below level $m$, the truncated Fourier series $F^{(m)}(\pmb\phi)$ gives a good approximation to the full loss function. Note that our recursive expansion generates $F^{(m)}(\pmb\phi)$ level by level, so the quality of the approximation can be gauged dynamically and the computation stopped when the necessary accuracy is reached.

We need to mention two caveats related to the approximation results stated. First, while small $L^2$ discrepancy guarantees good approximation for most parameter configurations, it is does not translate directly into point-wise convergence. Indeed, while the average absolute value of higher-level monomials \eqref{t def} is exponentially suppressed, their maximum values are independent of the order ($\operatorname{max}_{\pmb\phi}{t}_{I}(\pmb\phi)=1$). Second, the bound \eqref{F bound} may be too weak in practice, as it effectively assumes that all the final observables in the dressed Hamiltonian expansion above level $m$ have non-zero expectation values. In practice, we expect that only an exponentially small fraction of observables contributes to the loss function norm. Properly taking this into account can significantly strengthen the bound, but requires accounting for the structure of a particular circuit at hand. We illustrate this in a random circuit model discussed in Sec.~\ref{sec cases}.
\subsection{Is there a more efficient algorithm?} \label{sec complexity}
\begin{figure}
	\includegraphics[width=0.3\textwidth]{figures/complexity}
	\caption{A sketch of the hierarchy of scales in the problem.}
	\label{fig complexity}
\end{figure}
As sketched in Fig.~\ref{fig complexity}, our discussion features four different scales. The largest scale is set by the number of terms in the expansion of the dressed Hamiltonian. It depends only on the structure of the circuit and the Hamiltonian, and can contain up to $2^M$ terms. Moreover, the total number of nodes in the computational tree Fig.~\ref{fig tree} can only exceed the number of final observables by a constant factor, so the recursive expansion algorithm is optimal for computing the Fourier series of the dressed Hamiltonian.

Another scale corresponds to the number of non-zero terms in the Fourier expansion of the loss function. It quantifies the very complexity of describing the loss function by its Fourier expansion, and implies a limit to when such a description can be practical. As discussed in Sec.\eqref{sec truncation}, the truncated Fourier series can furnish good approximation to the full loss function while containing only a small fraction of all non-zero terms, which leads us to associate a separate scale to it.

The most relevant scale in practice, however, is set the by number of computation nodes, quantifying the complexity of the algorithm. Without accounting for the expectation values, it simply coincides with the number of terms in the dressed Hamiltonian. In Sec.~\ref{sec pruning} we explained how to prune the branches of the dressed Hamiltonian expansion with the expected saving being exponential in the number of qubits. Still, in general this leaves a large gap between the number of computational nodes and the number of non-zero terms in the loss function. Indeed, assume for simplicity that the first $N$ Pauli generators span an $X$-basis. While evaluating a computational node $(P_1\dots P_N|O)$ is efficient, the probability of getting a non-zero result will be generally be exponentially small in $N$, implying the most of these nodes were not necessary to generate in the first place. Can a more efficient pruning algorithm be developed?

Let us formalize the question. We can parameterize all possible final observables $O$ in the expansion of the dressed Hamiltonian by $M$ boolean variables $k_1,\dots, k_M$, which define whether $i$-th Pauli generator is included in the final observable or not, i.e. 
\begin{align}
	O=P_1^{k_1}\dots P_M^{k_M}H  .
\end{align}

To satisfy the branching rules, each Pauli generator with $k_i\neq 0$ must anti-commute with the product of all Pauli generators to the right. This gives a quadratic binary system of $M$ equations 
\begin{align}
	k_i\braket{P_i, H}+\sum_{j=i+1}^M k_ik_j \braket{P_i, P_j}=0 \ . \label{kikj}
\end{align}
Here $\braket{P_i, P_j}=1$ if $P_i$ anti-commutes with $P_j$ and zero otherwise. The condition for $O$ to have a non-zero expectation value is 
\begin{align}
	H(X)+\sum_{i=1}^M k_i P_i(X)=0 \ . \label{kiX}
\end{align}
This equation contains $N$ constraints for an $N$-qubit problem.

Together, branching constraints \eqref{kikj} and $X$-constraints \eqref{kiX} present an instance of a boolean multivariate quadratic problem (Boolean MQ), which is known to be NP-hard. State of the art algorithms \cite{Dinur2020, Barbero2022} have worst-case time complexities around $2^{0.69M}$ to find a solution or prove one does not exist. Due to the recurrent structure of equations \eqref{kikj}, our Boolean MQ instances are significantly simpler then the general case. As shown in the next section, for random circuits, which are expected to capture the worst case behavior in practice, time complexity around $2^{0.58(M-N)}$ is sufficient to find all solutions. Thus, while generic algorithms for the Boolean MQ problem are unlikely to be useful directly, there is a possibility that more efficient pruning techniques can be adopted in our scheme narrowing the gap between the number of computational nodes and non-zero coefficients in the loss function.


\section{Case studies} \label{sec cases}
So far we discussed general properties of the Fourier expansion for \CP{} circuits. In this section, we consider several specific examples that showcase how the expansions are structured in practice. We will both make analytic estimates and put the classical algorithm to work in numeric simulations.
\subsection{Random circuits}
\begin{figure}
	\begin{subfigure}{0.4\textwidth}
		\includegraphics[width=\hsize]{figures/random.png}
		\caption{}
		\label{fig random nodes}
	\end{subfigure}	

	\begin{subfigure}{0.4\textwidth}
		\includegraphics[width=\hsize]{figures/random_mc.png}
		\caption{}		
		\label{fig random scaling}
	\end{subfigure}
	
	\caption{Distribution of the number terms $l(m)$ (normalized) and norm $\nu(m)$ in Fourier expansion of the dressed Hamiltonian for random circuits. Datapoints are averages over 20 random circuits, filled areas quantify standard deviations, solid curves are theoretical predictions. Note that the distribution of norm is computed from the distribution of terms $\nu(m)=2^{-m}l(m)$.}
	\label{fig random}
\end{figure}
We first study the case where all the Pauli generators, as well as the Hamiltonian, are random Pauli operators with the support on all of the qubits. In this setup, it is simple to give probabilistic estimates for the expected distribution of Fourier terms in the loss function. 

In fact, the assumption that the Pauli generators are random is not necessary as long as the observable is random. Therefore, we expect this behavior to capture well the asymptotic limit of most sufficiently deep circuits. Indeed, even if the original Hamiltonian is local, as we go down the computational tree (see Fig.~\ref{fig tree}), the observables at the intermediate computational nodes become ever more scrambled and eventually behave as random Pauli operators. While it is possible to construct circuits that do not follow this pattern, exceptions are unlikely to occur generically.\\[4pt]
\textbf{\textit{Distribution of terms in the dressed Hamiltonian}}. 

We will first look at coarse-grained characteristics of the dressed Hamiltonian expansion, such as the number of non-zero terms at level $m$, denoted by $n_M(m)$, and the total number of terms $n_M=\sum_m n_M(m)$. When all $P_i$ and $H$ are random, the probability of branching at each computational node is $\frac12$. Therefore, on average, each iteration of the algorithm increases the total number of nodes $n_M$ by a factor of $\frac32$, leading to
\begin{align}
	n_M=\left(\frac32\right)^M \ . \label{nM}
\end{align}
The same reasoning applies to the number of non-zero computational nodes at each level $n_{M}(m)$, which hence satisfies the recurrence relation $n_{M+1}(m)=\frac12 n_{M}(m)+n_{M}(m-1)$ with the solution
\begin{align}
	n_{M}(m)=2^{m-M}\binom{M}{m} \ .
\end{align}
One can check that $\sum_{m=0}^M n_{M}(m)=n_M$.
\\[4pt]
\textbf{\textit{Distribution of terms in the loss function}}.
 
So far we discussed the distribution of Fourier terms in the dressed Hamiltonian, and now we turn to the loss function. Since every final observable of the dressed Hamiltonian is again a random Pauli, it has $2^{-N}$ probability of having non-zero expectation value. Therefore, the distribution of Fourier terms by level $l_M(m)$ is simply $l_M(m)=2^{-N}n_M(m)$. The expected number of all non-zero terms in the loss function is
\begin{align}
	l_M = 2^{-N}\left(\frac32\right)^{M} \ . \label{lM}
\end{align}
The exponent here $\log_2\frac32\approx 0.58$ is the value referenced in discussion of Sec.\ref{sec complexity}.

Now we recall that each term at level $m$ contributes exactly $2^{-m}$ to the $L^2$ norm. From the distribution of nodes by level we can derive the distribution of norm by level $\nu_{M}(m)=2^{-m}l_{M}(m)$, explicitly given by
\begin{align}
	\nu_{M}(m)=2^{-N-M}\binom{M}{m} \ . \label{binom}
\end{align}
Note that $\sum_{m=0}^M \nu_{M}(m)=2^{-N}$. At Fig.~\ref{fig random nodes} we plot results of numerical simulations for random circuits, which convincingly confirm our estimates for average distribution of nodes. 
\\[4pt]
\textbf{\textit{Accuracy of a truncated expansion}}. 

We can now address the question of how many terms need to be included in the loss function to give a good $L^2$ approximation. Since binomial distribution \eqref{binom} is symmetric around $m=\frac{M}{2}$, including Fourier terms up to level $\frac{M}{2}$ will on average account for $50\%$ of the norm. The total number of nodes at the included levels can be estimated as $l_M(\frac{M}{2})\sim 2^{\frac{M}2-N}$. While in the large $M$ limit this is an exponentially small fraction of all terms \eqref{lM}, the number of relevant terms itself is still an exponential in $M$.
\\[4pt]
\textbf{\textit{Complexity of the algorithm and simulation limits.}}

Exponential increase in the number of relevant terms with $M$ clearly limits the depth of the circuits we can address. Importantly, the property that most final observables have zero expectation values in turn limits the number of qubits $N$ we can meaningfully simulate. While in principle, the number of qubits is only limited by the simulation cost for Clifford circuits, to get a loss function which is not zero everywhere the number of Pauli rotation gates $M$ needs to increase with $N$.

Indeed, the requirement that $l_M$ stays constant as we increase $N$ implies depth scaling $M\sim N/\log_2\frac32$. Thanks to the subroutine filtering by the expectation value, we do not need to generate the full expansion of the dressed Hamiltonian. Assuming that the first $N$ Pauli generators are independent, we only need to produce $\left(\frac32\right)^{M-N}\approx 10^{N/8}$ nodes. As reported in Fig.\ref{fig random scaling}, this scaling is well confirmed numerically.

With a computational budget to process $10^6$ nodes, which is at a laptop scale, the loss function for a $50$-qubit random circuit with $85$ Pauli rotation gates can be computed exactly. With resources to process $10^{12}$ nodes, which should be feasible on a computational cluster, $100$-qubit circuits with about $170$ Pauli gates can be handled.

\subsection{QAOA}
Variational circuits appearing in practice are far from the random Pauli model described above. Instead, they typically only involve local gates and observables. Although we expect the random Pauli model to describe well the large depth asymptotic, circuits of shorter depth may behave quite differently. Indeed, until the observables at computational nodes become sufficiently scrambled to behave like random ones, the branching probability is much smaller than $\frac12$ and the complexity growth is much slower. This allows to compute Fourier expansions for circuits with much higher depths then anticipated for the random model.

As a case study we consider instances of the Quantum Approximate Optimization Algorithm (QAOA) for the MaxCut problem on regular graphs \cite{Farhi2014}, which is the best studied approach to a combinatorial optimization. Two most important characteristics is of a particular QAOA circuit is the degree of a graph $d$ and the number of layers $p$, see App.\ref{app QAOA} for details. 


Due to locality, shallow instances of QAOA allow for efficient classical computation of the loss function independently of the number of qubits. To every observable one associates a reverse light cone, containing all qubits that are connected to the observable by the entangling gates. For graphs of bounded degree, the size of the reverse light cone stays constant in the large $N$ limit and classical computation of the loss function never involves simulating quantum circuits larger than that size. For 
QAOA on a graph of degree $d$ with $p$ layers the size of the reverse light cone is bounded by \cite{Farhi2014}
\begin{align}
	N_c=2\frac{(d-1)^{p+1}-1}{d-2} \ . \label{q QAOA}
\end{align}
Note that $N_c$ scales exponentially with the level $p$, so that large $p$ regime is the most difficult to simulate. 

Large $p$ also implies large number of parametric gates, which is the key limiting factor for our algorithm. At the same time, while the locality of gates is not necessary in our approach, it certainly helps. Moreover, the benefits of locality are incorporated automatically. The Pauli generators supported outside the reverse light cone of the Hamiltonian commute with all observables at the computational nodes and are trivially eliminated. Using a basic Monte-Carlo sampling, we estimated the expected complexity of our algorithm to compute the full Fourier expansion of the loss function for several values of $d$ and $p$. Results are presented in Tab.~\ref{tab QAOA}, details of numerical simulations are specified in App.\ref{app QAOA}. 

We stress here that the special structure of QAOA circuits and observables makes it possible to handle much larger number of parameters compared to random circuits. Indeed, for a $d$-regular graph with $N$ nodes there are exactly $|E|=Nd/2$ edges, so the number of parametric gates in our simulations is given by
\begin{align}
	M=p(N_c+|E|)=pN_c\left(\frac{d}{2}+1\right) \ .
\end{align}
For instance, for $p=3, d=3$ this gives $N_c=30, M=225$, and the a random circuit in this setup would require processing $\sim \left(\frac32\right)^{M-N_c}\simeq 2.18\times 10^{34}$ computational nodes, clearly an unmanageable amount. In contrast, for the actual QAOA instance we find that about $10^9$ computational nodes is sufficient. At the same time, the node distribution by level is qualitatively similar to the random case of the same complexity, see App.\ref{app QAOA} for details.
\begin{table}
	\begin{tabular}{cllll}
		\toprule
	degree$\backslash$level&  1 & 2 & 3&\\ \hline
      2  &0.7  &2  &4  \\
	  3	&1  &3.7  &8.2 &  \\
      \bottomrule
	\end{tabular}
\caption{Estimated number of computational nodes to exactly compute Fourier expansion for QAOA circuits of varying degree and level. For each $d, p$ 20 random QAOA instances are generated. For each instance a single observable is chosen. Values in the table give number of computational nodes averages over different samples, $\pm$ quantify standard deviations. Estimates for each circuit are computed from Monte-Carlo simulations with $10^4$ samples.}
\label{tab QAOA}
\end{table}
\subsection{Hardware-efficient circuits}
One frequently studied design of variational algorithms is the hardware-efficient form \cite{Kandala2017}, where the circuit is constructed to give the maximal expressivity with limited depth, efficiently using native hardware gates. 

We consider hardware-efficient circuit with brick wall arhictecture, where each block is built of an entangling $\CZ$ gate and four single-qubit Pauli rotations, see App.\ref{app HEA} for details. In this setting, we estimate the complexity of our algorithm to exactly compute the loss function and report the results in Fig.\ref{fig HEA}. The takeaway is similar to the QAOA case, locality of the circuit and the observable strongly reduces the number of Fourier terms compared to the random case, so the computational budget needed to process random circuits with $M\sim 80$ should be sufficient to simulate $M\sim600$ parametric gates in the current local setup.
\begin{figure}
	\includegraphics[width=0.45\textwidth]{figures/hea.png}
	\caption{HEA}
	\label{fig HEA}
\end{figure}





\onecolumngrid


\appendix
\section{Structure of a generic Fourier expansion} \label{app explicit}
\subsection{Level expansion and number of terms}
For the sake of clarity, here we give a more detailed description of the general structure of Fourier expansion for the loss function introduced in Sec.~\ref{sec VQA}. Let us first illustrate trigonometric expansion of the unitary \eqref{U expansion} for the case with $M=2$ angles
\begin{align}
	U(\phi_1,\phi_2) = U_{00}\cos\frac{\phi_1}{2}\cos\frac{\phi_2}{2}+U_{01}\cos\frac{\phi_1}{2}\sin\frac{\phi_2}{2}+U_{10}\sin\frac{\phi_1}{2}\cos\frac{\phi_2}{2}+U_{11}\sin\frac{\phi_1}{2}\sin\frac{\phi_2}{2} \ . \label{U2}
\end{align}
Note that trigonometric monomials here have the same degree and period $4\pi$. Substituting such expansions into the definition of the loss function \eqref{F def} leads to the Fourier series expansion of the loss function. Applying identities $\cos^2\frac{\phi}{2}=\frac{1+\cos\phi}{2}, \sin^2\frac{\phi}{2}=\frac{1-\cos\phi}{2}, \cos\frac{\phi}{2}\sin\frac{\phi}{2}=\frac{\sin\phi}{2}$ leads to an expression involving trigonometric monomials of a smaller period $2\pi$ and degrees up to $M$. For instance 
\begin{align}
	F(\phi_1,\phi_2)=\Braket{0|U^\dagger(\phi_1,\phi_2)HU(\phi_1,\phi_2)|0}=\frac14\Braket{0|U_{00}^\dagger HU_{00}|0}\left(1+\cos\phi_1+\cos\phi_2+\cos\phi_1\cos\phi_2\right)+\dots
\end{align}
and we wrote explicitly only the contribution from the first term.

More generally, terms in the expansion \eqref{Fm def} assume the following form
\begin{align}
F_0=\text{const},\quad
F_1(\pmb\phi)=\sum_{i=1}^M F_i(\phi_i), \quad F_2(\pmb\phi)=\sum_{i,j=1}^M F_{ij}(\phi_i,\phi_j), \quad F_3(\pmb\phi)=\sum_{i,j,k=1}^M F_{ijk}(\phi_i,\phi_j,\phi_k),\quad\dots
\end{align}
Here
\begin{align}
\begin{split}
&F_i(\phi_i)=A_i\cos\phi_i+B_i\sin\phi_i\\
&F_{ij}(\phi_i,\phi_j)=A_{ij}\cos\phi_i\cos\phi_j+B_{ij}\cos\phi_i\sin\phi_j+C_{ij}\sin\phi_i\cos\phi_j+D_{ij}\sin\phi_i\sin\phi_j\\
&\dots
\end{split}
\end{align}
At each level $m$ there are $\binom{M}{m}$ subsets of parameters, enumerating possible indices of homogeneous polynomials $F_{i_1\dots i_m}$. To define the polynomial for each parameter configuration requires specifying $2^m$ coefficients. This leads to the counting \eqref{3M coeffs} for the total number of coefficients in the Fourier series.
\subsection{Coefficients from averages}
Trivially $F_0=\Braket{F(\pmb\phi)}_{\pmb\phi}$. Higher order terms can be obtained similarly. For instance, $F_i(\phi_i)=\Braket{F(\pmb\phi)-F_0}_{\pmb\phi\neq\phi_i}$, i.e. averaging over all angles except $\phi_i$ only leaves first-order monomials involving a given angle $\phi_i$. Higher order terms can be found recursively. Note that in this prescription to compute terms at level $m$ requires to first compute and subtract the contribution all levels below $m$.
\section{Details of numerical computations}
\subsection{QAOA} \label{app QAOA}
Given a graph $G$ with vertices $E_{ij}$, a single layer of the QAOA circuit consists of Pauli rotation gates $Z_iZ_j(\gamma_{ij})$ for each edge $E_{ij}$, followed by the sequence of single-qubit $X_i(\beta_i)$ gates placed on every qubit. Note that in the standard formulation of QAOA, $\gamma_{ij}=\gamma, \beta_i=\beta$ $\gamma_{ij}$ i.e. all $ZZ$ gates and all $X$ gates have the same parameters within each layer. However, taking this correlation into account does not simplify our analysis and we will not impose it. Single layer repeated $p$ times gives an instance of QAOA${}_p$ circuit. The Hamiltonian is given by the sum of all $Z$-Pauli generators $H=\sum_{E_{ij}}Z_iZ_j$.

 To estimate complexity of the computing mean values for QAOA it is thus sufficient consider circuits of size \eqref{q QAOA}.
\subsection{Hardware-efficient circuits} \label{app HEA}


\section{Optimizing Pauli order}
Delayed branching, advanced pruning
\bibliographystyle{utcaps_edited.bst}
\bibliography{/home/idnm/Dropbox/hep/Sheets/library.bib}

\end{document}